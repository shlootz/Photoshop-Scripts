#target photoshop#include "json2.js"#include "descriptor-info.jsx"#include "MS/[M] Undeform Alex test.jsx"app.bringToFront();// This script exports Adobe Photoshop layers as individual PNGs. It also// writes a JSON file which can be imported into Spine where the images// will be displayed in the same positions and draw order.// Copyright (c) 2012-2017, Esoteric Software// All rights reserved.// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met://     * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.//     * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.//     * Neither the name of Esoteric Software nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.var cs2 = parseInt(app.version) < 10;var versionTool = "v1.1.20";var originalDoc;try {	originalDoc = app.activeDocument;} catch (ignored) {$.writeln("1 ERROR "+ignored)}originalDoc.save();alert("Cthulhu is checking your smart objects. Cthulhu likes to take his time. Don't panic. Don't call Alex. Click OK, sit back, and relax."); if(app.activeDocument.activeLayer.allLocked) app.activeDocument.activeLayer.allLocked = false;   var history = app.activeDocument.historyStates.length - 1;var allDocumentTexts = new Array();  var defaultSettings = {	writeTemplate: false,	ignoreHiddenLayers: true,	ignoreBackground: true,	scale: 1,	padding: 0,	imagesDir: "./images/",	jsonPath: "./",    cleanBloat: false,    ignoreJSON: false,    onlyJSON:false,    difJSON:false,    mode:"desktop" };//modes: "desktop",  "mobile_portrait",  "mobile_landscape"var masterLayout;var masterLayoutSlots;var masterLayoutSkins;var smartLayers = new Array();var uniqueLayers = {};var layersNames = {};var curr = 0;var layersWithIssues = [];var progress, cancel;var layersToRemove = [];function deleteDocumentAncestorsMetadata() {      whatApp = String(app.name);//String version of the app name      if(whatApp.search("Photoshop") > 0)  { //Check for photoshop specifically, or this will cause errors          //Function Scrubs Document Ancestors from Files          if(!documents.length) {          alert("There are no open documents. Please open a file to run this script.")          return;           }          if (ExternalObject.AdobeXMPScript == undefined) ExternalObject.AdobeXMPScript = new ExternalObject("lib:AdobeXMPScript");           var xmp = new XMPMeta( activeDocument.xmpMetadata.rawData);           // Begone foul Document Ancestors!              xmp.deleteProperty(XMPConst.NS_PHOTOSHOP, "DocumentAncestors");              app.activeDocument.xmpMetadata.rawData = xmp.serialize();           }  }  //Now run the function to remove the document ancestors  //deleteDocumentAncestorsMetadata();showProgressDialog ()var settings = loadSettings();var nameCounter = 0;renameDuplicates();//canRunScript(); //goes through the smart objects and prepares the for what's comingshowSettingsDialog();function renameDuplicates(){    var allDocLayers = returnAllLayers(originalDoc, allDocLayers);    $.writeln("uniqued names "+uniqueLayers);    }function returnAllLayers (doc, allLayers){            var curr = 0;            for (var m = 0; m < doc.layers.length; m++){                var theLayer = doc.layers[m];                if(theLayer.visible){                    nameCounter ++;                    if (theLayer.layers && theLayer.layers.length > 0)                    {                         returnAllLayers(theLayer, allLayers);                    } else {                        curr ++;                     //renaming all layers to avoid duplicates, internal use only                            theLayer.name = theLayer.name+"!@"+theLayer.parent.name+"_"+nameCounter;                           }                }            }            return allLayers;}function checkIfNewLayerName(name){    var found = false;    if(uniqueLayers[name] === undefined)    {        found = true;        }  return found;}function run () {    if(settings.cleanBloat) {        deleteDocumentAncestorsMetadata();        }        //canRunScript();     //checkTextLayers();        showProgressDialog();	// Output dirs.   // if(settings.ignoreJSON.value == true){   var jsonFile = new File(jsonPath(settings.jsonPath));   jsonFile.parent.create();   // }	var imagesDir = absolutePath(settings.imagesDir);	var imagesFolder = new Folder(imagesDir);    if(!settings.onlyJSON) imagesFolder.create();	var relImagesDir = imagesFolder.getRelativeURI(jsonFile.parent);	relImagesDir = relImagesDir == "." ? "" : (relImagesDir + "/");	// Get ruler origin.	var action = new ActionReference();	action.putEnumerated(cID("Dcmn"), cID("Ordn"), cID("Trgt"));	var result = executeActionGet(action);	var xOffSet = result.getInteger(sID("rulerOriginH")) >> 16;	var yOffSet = result.getInteger(sID("rulerOriginV")) >> 16;	activeDocument.duplicate();    canRunScript();     checkTextLayers();        showProgressDialog();	deselectLayers();	try {		convertToRGB();	} catch (ignored) {$.writeln("2 ERROR "+ignored)}	if (app.activeDocument.mode != DocumentMode.RGB) {		alert("Please change the image mode to RGB color.");		return;	}	// Output template image.	if (settings.writeTemplate) {		if (settings.scale != 1) {			scaleImage();			storeHistory();		}            var file = new File(imagesDir + "template.png");            if (file.exists) file.remove();            savePNG(file);            if (settings.scale != 1) restoreHistory();        }    	if (!settings.jsonPath && !settings.imagesDir) {		activeDocument.close(SaveOptions.DONOTSAVECHANGES);		return;	}	// Rasterize all layers.    //executeAction(sID("rasterizeAll"), undefined, DialogModes.NO);	try {		executeAction(sID("rasterizeAll"), undefined, DialogModes.NO);	} catch (ignored) {$.writeln("3 ERROR "+ignored)}	// Collect and hide layers.	var layers = [];	collectLayers(activeDocument, layers);	var layersCount = layers.length;	activeDocument.artLayers.add(); // Add a history item to prevent restoreHistory from affecting layer visibility.	// Store the slot names and layers for each skin.	var slots = {}, skins = { "default": [] };    var parents = {};    var uids = {};	var slotsCount = 0, skinsCount = 0, totalLayerCount = 0;	outer:	for (var i = 0; i < layersCount; i++) {		var layer = layers[i]["layer"];         var uid = layers[i]["uid"];             		layer.attachmentName = folders(layer, "") + stripTags(layer.name);		layer.slotName = hasTag(layer, "slot", layer.attachmentName);		if (!slots.hasOwnProperty(layer.slotName)) slotsCount++;		slots[layer.slotName] = layer.wasVisible ? layer.attachmentName : null;         parents[layer.slotName] = iterateParents(layer, parents);                  uids[layer.slotName] = uid;		var skinName = hasTag(layer, "skin", "default");		var skinSlots = skins[skinName];		if (!skinSlots) {			skins[skinName] = skinSlots = {};			skinsCount++;		}		var skinLayers = skinSlots[layer.slotName];		if (!skinLayers) skinSlots[layer.slotName] = skinLayers = [];		/*for (var ii = 0, nn = skinLayers.length; ii < nn; ii++) {			if (skinLayers[ii].attachmentName == layer.attachmentName) {				alert("Multiple layers for the \"" + skinName + "\" skin have the same name:\n\n"					+ layer.attachmentName					+ "\n\nRename or use the [ignore] tag for the other layers.");				return;			}		}*/		skinLayers[skinLayers.length] = layer;		totalLayerCount++;	}	// Output skeleton and bones.	var json = '{"skeleton":{"images":"' + relImagesDir + '","mode":"'+settings.mode+'"},"bones":[{"name":"root"}],\n"slots":[\n';	// Output slots.	var slotIndex = 0;	for (var slotName in slots) {		if (!slots.hasOwnProperty(slotName)) continue;		var attachmentName = slots[slotName];         var uniqueID = uids[slotName];         var parentName = parents[slotName]         var folderName = "layer.parent.name";		if (attachmentName)			json += '\t{"layer":' + quote(stripJunkFromName(parentName)) + ',"name":' + quote(stripJunkFromName(slotName)) +',"bone":"root","attachment":' + quote(stripJunkFromName(attachmentName)) + ',"uid":"'+uniqueID+'"}';		else			json += '\t{"layer":' + quote(stripJunkFromName(parentName)) + ',"name":' + quote(stripJunkFromName(slotName)) +',"bone":"root"}';		slotIndex++;		json += slotIndex < slotsCount ? ",\n" : "\n";	}	json += '],\n"skins":{\n';	// Output skins.	var skinIndex = 0, layerCount = 0;	for (var skinName in skins) {        $.writeln("-");		if (!skins.hasOwnProperty(skinName)) continue;		json += '\t"' + skinName + '":{\n';		var skinSlots = skins[skinName];		var skinSlotIndex = 0, skinSlotsCount = countAssocArray(skinSlots);		for (var slotName in skinSlots) {             $.writeln("-- "+slotName);			if (!skinSlots.hasOwnProperty(slotName)) continue;//uniqueID			json += '\t\t' + '"' +uids[slotName] + '"'+':{\n';			var skinLayers = skinSlots[slotName];			var skinLayerIndex = 0, skinLayersCount = skinLayers.length;			for (var i = skinLayersCount - 1; i >= 0; i--) {                 $.writeln("---");				var layer = skinLayers[i];				layer.visible = true;				if (cancel) {					activeDocument.close(SaveOptions.DONOTSAVECHANGES);					return;				}				setProgress(++layerCount / totalLayerCount, trim(layer.name));                  var textObjProperties = "";                  var textW = 0;                  var textH = 0;                  var textX = 0;                  var textY = 0;                  var isText = false;				var placeholderName = layer.attachmentName;				var attachmentName = (skinName == "default" ? "" : skinName + "/") + placeholderName;				if (isGroup(layer)) {					activeDocument.activeLayer = layer;					layer = layer.merge();				}                              if(allDocumentTexts != null)  {                      for (var u = 0; u<allDocumentTexts.length; u++){                        var textsHolder = allDocumentTexts[u];                              if( textsHolder.hasOwnProperty(attachmentName)) {                                   isText = true;                                   textObjProperties = ',"type":"textField", "properties":{"fontName": "'+ textsHolder[attachmentName]["fontName"] + '","fontSize": "' + textsHolder[attachmentName]["fontSize"] + '", "fontColour":"'+textsHolder[attachmentName]["fontColour"]+ '", "justification":"'+textsHolder[attachmentName]["justification"]+ '", "value":"'+textsHolder[attachmentName]["value"]+'"}';                                   textW = textsHolder[attachmentName]["w"];                                   textH = textsHolder[attachmentName]["h"];                                   textX = textsHolder[attachmentName]["x"];                                   textY = textsHolder[attachmentName]["y"];                                }                        }                    }                                                   $.writeln("<><><><><><><><><> "+getLayerColourByID(layer.id));                                  $.writeln("start storing history");                                storeHistory();                                  $.writeln("end storing history");                                  $.writeln("start setting up active document");                                var x = activeDocument.width.as("px") * settings.scale;                                var y = activeDocument.height.as("px") * settings.scale;                                                                // SHOULD I CROP HERE INSTEAD OF TRIM??/*var bounds = [54, 12, 354, 246];doc.crop(bounds);        */                                                                if (!layer.isBackgroundLayer) activeDocument.trim(TrimType.TRANSPARENT, false, true, true, false);                                x -= activeDocument.width.as("px") * settings.scale;                                y -= activeDocument.height.as("px") * settings.scale;                                if (!layer.isBackgroundLayer) activeDocument.trim(TrimType.TRANSPARENT, true, false, false, true);                                var width = activeDocument.width.as("px") * settings.scale + settings.padding * 2;                                var height = activeDocument.height.as("px") * settings.scale + settings.padding * 2;                                   $.writeln("end setting up active document");                                // Save image.                                 $.writeln("start save image "+attachmentName);                                if (settings.imagesDir) {                                    if (settings.scale != 1) scaleImage();                                    if (settings.padding > 0) activeDocument.resizeCanvas(width, height, AnchorPosition.MIDDLECENTER);                                      if (getLayerColourByID(layer.id) != "red" && attachmentName.indexOf("_noExport") === -1)  {                                      //if (getLayerColourByID(layer.id) != "red")  {                                          if(!settings.onlyJSON){                                                var file = new File(imagesDir + "/"+stripJunkFromName(parents[attachmentName])+stripJunkFromName(attachmentName));                                                file.parent.create();                                                savePNG(file);                                                }                                            }                                        }                                                                   $.writeln("end save image");                                                                      $.writeln("start restore history");                                restoreHistory();                                  $.writeln("end restore history");                                  $.writeln("start remove layers");                                if (layerCount < totalLayerCount) layer.remove();                                  $.writeln("end restore history");                                                     var smartJson = "";                  smartLayers.reverse();                  for (var smartO=0; smartO<smartLayers.length; smartO++)                  {                      if(attachmentName === smartLayers[smartO])                      {                          if(layerNameToLayerIndex!= undefined);                          {                               var allProps = layerNameToLayerIndex;                               var props = allProps[attachmentName];                                if (JSON.stringify(props).indexOf("angle") >= 0) {                                    smartJson += ',"angle":'+String(Number(props["angle"])*(-1));                                    smartJson += ',"scaleW":'+String(100/Number(props["scale"]["width"]));                                    smartJson += ',"scaleH":'+String(100/Number(props["scale"]["height"]));                                    smartJson += ',"smartWidth":'+props["originalSize"]["width"];                                    smartJson += ',"smartHeight":'+props["originalSize"]["height"];                                    //width = props["originalSize"]["width"];                                    //height = props["originalSize"]["height"];                                }                            else                             {                                //$.writeln("!!!!!!!! issues with layer "+ stripJunkFromName(attachmentName));                                    layersWithIssues.push(stripJunkFromName(attachmentName));                                    smartJson += ',"angle":'+String(0);                                    smartJson += ',"scaleW":'+String(1);                                    smartJson += ',"scaleH":'+String(1);                                }                             }                        }                      }				x += Math.round(width) / 2 - settings.padding;				y += Math.round(height) / 2 - settings.padding;				// Make relative to the Photoshop document ruler origin.				x -= xOffSet * settings.scale;				y -= (activeDocument.height.as("px") - yOffSet) * settings.scale;				json += "\t\t\t" + quote(stripJunkFromName(placeholderName)) + ':{';				if (attachmentName != placeholderName) json += '"name":' + quote(stripJunkFromName(attachmentName)) + ', ';                  $.writeln("§§§§§§§ "+ textObjProperties);                  if (textObjProperties.indexOf("fontName") > 0) {                      if (textW != undefined){                            $.writeln("§§§§§§§ "+ textW + " "+textH+" "+textX+" "+textY);                            width = textW;                            height = textH;                            x = String(Number(textX) + Number(textW)/2);                            y = String((Number(textY) + Number(textH)/2)*(-1));                        }                        //y = textY;                      }                                    				json += '"x":' + x + ',"y":' + y + ',"width":' + Math.round(width) + ',"height":' + Math.round(height) + smartJson + textObjProperties;				json += "}" + (++skinLayerIndex < skinLayersCount ? ",\n" : "\n");			}			json += "\t\t}" + (++skinSlotIndex < skinSlotsCount ? ",\n" : "\n");		}		json += "\t\}" + (++skinIndex < skinsCount ? ",\n" : "\n");	}	json += '},\n"animations":{"animation":{}}\n}';    $.writeln(json);	activeDocument.close(SaveOptions.DONOTSAVECHANGES);	// Output JSON file.	if (settings.jsonPath && !settings.ignoreJSON && !settings.difJSON) {		jsonFile.encoding = "UTF-8";		jsonFile.remove();		jsonFile.open("w", "TEXT");		jsonFile.lineFeed = "\n";                var objToWrite = JSON.parse(json);                objToWrite["slots"].sort(orderByUID);        //objToWrite["slots"].reverse();                     json = JSON.stringify(objToWrite);        		jsonFile.write(json);		jsonFile.close();	} else {           if(settings.jsonPath && settings.difJSON) {                      $.writeln("!!!!!!!!!!!!!");                      $.writeln(json);                    var source = JSON.parse(json);                                        for (var slotName in slots){                        var isNew = true;                        var junkName = slotName;                        var newSlot;                        var newSkin;                         for(var i = 0; i<masterLayout["slots"].length; i++)                         {                              junkName = masterLayout["slots"][i]["name"];                             if(stripJunkFromName(masterLayout["slots"][i]["name"]) === stripJunkFromName(slotName))                             {                                                                 $.writeln("UPDATE "+junkName+" and skin is:");                                                                                                  var id = masterLayout["slots"][i]["uid"];                                var sourceObj = findSource(source, slotName, uids);                                var sourceSlot = findSlot(source, masterLayout["slots"][i]["name"]);                                var targetObj = masterLayout["skins"]["default"][id];                                                                targetObj = sourceObj;                                masterLayout["slots"][i]["layer"] = sourceSlot["layer"];                                masterLayout["skins"]["default"][id] = sourceObj;                                $.writeln("Source OBJ = "+sourceObj);                                                                isNew = false;                                }                                                         }                                                  if (isNew)                          {                                                           $.writeln("INSERT "+slotName);                                                                   newSlot = findSlot(source, stripJunkFromName(slotName))                                                          $.writeln("FOUND SLOT "+newSlot);                                                            newSkin = findSource(source, slotName, uids);                                                          $.writeln("FOUND SKIN "+newSkin);                                                           var newSlotObj = {"layer":newSlot["layer"],                                   "name":newSlot["name"],                                   "bone":newSlot["bone"],                                   "attachment":newSlot["attachment"],                                   "uid":newSlot["uid"]                                   }                                                                  //masterLayout["slots"].push(newSlotObj);                               masterLayout["slots"].splice(i, 0, newSlotObj);                                            masterLayout["skins"]["default"][newSlot["uid"]] = newSkin;                                                        }                        else {                                                        }                        }            }                masterLayout["slots"].sort(orderByUID);        //masterLayout["slots"].reverse();        //masterLayout["slots"].sort(compareLayerName);                var updateJson = JSON.stringify(masterLayout);        //$.writeln(updateJson);         jsonFile.encoding = "UTF-8";		jsonFile.remove();		jsonFile.open("w", "TEXT");		jsonFile.lineFeed = "\n";		jsonFile.write(updateJson);		jsonFile.close();        }           // app.activeDocument.activeHistoryState = app.activeDocument.historyStates[0];    // app.activeDocument.activeHistoryState = app.activeDocument.historyStates[initialHistoryState];    //app.activeDocument.activeHistoryState = app.activeDocument.historyStates[history];    //app.purge (PurgeTarget.HISTORYCACHES);           revertToInitialSave();        alert("Export Complete!");    }function revertToInitialSave(){     var idRvrt = charIDToTypeID( "Rvrt" );        executeAction( idRvrt, undefined, DialogModes.NO );    }function stripJunkFromName(name){var str = name;str = str.replace(".png", "");return (str.split("!@")[0]);}function orderByUID(a,b) {  if (Number(a["uid"]) < Number(b["uid"]))    return -1;  if (Number(a["uid"]) > Number(b["uid"]))    return 1;  return 0;}function findSlot(source, name){    var found;      for(var i=0; i<source["slots"].length; i++){      $.writeln("--------------- searching "+source["slots"][i]["name"]);        if(stripJunkFromName(source["slots"][i]["name"]) == stripJunkFromName(name)){              found = source["slots"][i];              $.writeln("---------------  FOUND ");               return found;                }    }        $.writeln("--------------- NOT FOUND ");    return undefined;        }function findSource(source, name, uids){    var found;    var id;    for (var i=0; i<source["slots"].length; i++){        if(source["slots"][i]["name"] == name){             $.writeln("---------Found name "+source["slots"][i]["name"]);            id = source["slots"][i]["uid"];            }        }        $.writeln("---------- skin ID for "+name+" UID = "+uids[name]);        found = source["skins"]["default"][uids[name]];    return found;        }function checkSmartLayersss(layer){        // Are you a smart object?       if(layer.parent.visible){           if (layer.kind == "LayerKind.SMARTOBJECT" && layer.visible) {                      $.writeln("±±±±±±±±±±±±±±±±± SMART LAYER "+layer.name+"");                      smartLayers.push(layer.name);               }            }    }function checkTextLayers(){    getAllVisibleLayers(app.activeDocument.layers);}function getAllVisibleLayers(layers){    for(var i = 0; i<layers.length; i++){        if(layers[i].visible) {            $.writeln(layers[i].name+" "+layers[i].layers);            checkSmartLayersss(layers[i]);            //getSmartObjectProperties();            if(layers[i].layers != undefined){                    if(layers[i].layers.length > 0){                        getAllVisibleLayers(layers[i].layers);                        }                                                        } else {                                           var layer = layers[i];                     //  $.writeln("SCALE "layer.property("Scale").value);                       var texts = {};                                                if(layer.kind==undefined){                                continue;                         }                        if(layer.kind == LayerKind.TEXT){                            if(layer.textItem.kind == TextType.POINTTEXT) {                                $.writeln('--------------------------------- NOT PARAGRAPH ');                                var textProperties = {};                                  textProperties["justification"] = formatJustification(layer.textItem.justification);                                 textProperties["fontColour"] = "FFFFFF";                                 textProperties["fontSize"] = layer.textItem.size;                                 textProperties["value"] =  encodeURI(layer.textItem.contents);                                 textProperties["fontName"] =  "NotoSans-Regular";                                 texts[layer.name] = textProperties;                                 allDocumentTexts.push(texts);                                $.writeln('--------------------------------- NOT PARAGRAPH ');                             }                         else {                             var textProperties = {};                              $.writeln('--------------------------------- '+layer.name);                             $.writeln('---------------------------------   font: '+ layer.textItem.font);                             $.writeln('---------------------------------   font: '+ layer.textItem.font +' font-size: ' + layer.textItem.size);                             if(layer.textItem.hasOwnProperty("color")) {                                //$.writeln('---------------------------------   font: '+ layer.textItem.font +' font-size: ' + layer.textItem.size + ' color: #' + layer.textItem.color.rgb.hexValue);                             }                                                            var px = String(layer.textItem.position[0]).split(" px");                                var py = String(layer.textItem.position[1]).split(" px");                                   var renamedFont = "";                                       var content = layer.textItem.contents;                                layer.textItem.contents = "LOREMIPSUNDOLORSITAMETLOREMIPSUNDOLORSITAMETLOREMIPSUNDOLORSITAMETLOREMIPSUNDOLORSITAMETLOREMIPSUNDOLORSITAMETLOREMIPSUNDOLORSITAMETLOREMIPSUNDOLORSITAMET";                                layer.textItem.contents += "LOREMIPSUNDOLORSITAMETLOREMIPSUNDOLORSITAMETLOREMIPSUNDOLORSITAMETLOREMIPSUNDOLORSITAMETLOREMIPSUNDOLORSITAMETLOREMIPSUNDOLORSITAMETLOREMIPSUNDOLORSITAMET";                                layer.textItem.contents += "LOREMIPSUNDOLORSITAMETLOREMIPSUNDOLORSITAMETLOREMIPSUNDOLORSITAMETLOREMIPSUNDOLORSITAMETLOREMIPSUNDOLORSITAMETLOREMIPSUNDOLORSITAMETLOREMIPSUNDOLORSITAMET";                                layer.textItem.contents += "LOREMIPSUNDOLORSITAMETLOREMIPSUNDOLORSITAMETLOREMIPSUNDOLORSITAMETLOREMIPSUNDOLORSITAMETLOREMIPSUNDOLORSITAMETLOREMIPSUNDOLORSITAMETLOREMIPSUNDOLORSITAMET";                                                                   if(layer.textItem.font == "NotoSans"){                                     renamedFont = "NotoSans-Regular"                                     }                                 textProperties["fontName"] = renamedFont;                                 textProperties["fontSize"] = layer.textItem.size;                                 textProperties["justification"] = "center";                                                                                                     try {                                         textProperties["justification"] = formatJustification(layer.textItem.justification);                                          textProperties["w"] = layer.bounds[2] - layer.bounds[0];                                         textProperties["h"] = layer.bounds[3] - layer.bounds[1];                                         textProperties["x"] = px[0];                                         textProperties["y"] = py[0];                                         textProperties["fontColour"] = layer.textItem.color.rgb.hexValue;                                         textProperties["value"] = encodeURI(layer.textItem.contents);                                     } catch (e){                                         $.writeln("4 ERROR "+e)                                         //alert("Textfield "+layer.name+" has an error and might be exported as image");                                         layersWithIssues.push(stripJunkFromName(layer.name));                                         //Setting some defaults                                         textProperties["justification"] = formatJustification("Justification.LEFT");                                         //textProperties["w"] = layer.width;                                         //textProperties["h"] = layer.height;                                         textProperties["w"] = layer.bounds[2] - layer.bounds[0];                                         textProperties["h"] = layer.bounds[3] - layer.bounds[1];                                         textProperties["x"] = layer.x;                                         textProperties["y"] = layer.y;                                         textProperties["fontColour"] = layer.textItem.color.rgb.hexValue;                                         textProperties["value"] = encodeURI("THIS TEXTFIELD HAS AN ISSUE");                                         texts[layer.name] = textProperties;                                         allDocumentTexts.push(texts);                                         continue;                                        }                             textProperties["fontColour"] = layer.textItem.color.rgb.hexValue;                             textProperties["value"] = encodeURI(content);                                                     texts[layer.name] = textProperties;                             allDocumentTexts.push(texts);                             }                        }                    }                }            }        }function formatJustification(justification){    var formatted = "";    switch(justification) {    case Justification.LEFT:    formatted = "left";        break;             case Justification.RIGHT:      formatted = "right";        break;                 case Justification.CENTER:         formatted = "center";         break;                default:         formatted = "left";    }return formatted}function dumpLayerSets(layerSets){    var len = layerSets.length;    for(var i=0;i<len;i++){         var layerSet = layerSets[i];            dumpLayers(layerSet.artLayers);                          }}function dumpLayers(layers){    var len = layers.length;    var texts = {};    for(var i=0;i<len;i++){         var layer = layers[i];         if(layer.kind==undefined){                continue;         }        /*if(layer.kind == LayerKind.TEXT){         var textProperties = {};          $.writeln('font: '+ layer.textItem.font +' font-size: ' + layer.textItem.size + ' color: #' + layer.textItem.color.rgb.hexValue);         textProperties["fontName"] = layer.textItem.font;         textProperties["fontSize"] = layer.textItem.size;         textProperties["fontColour"] = layer.textItem.color.rgb.hexValue;         texts[layer.name] = textProperties;        }    }    allDocumentTexts.push(texts);*/    }}function determinelayerkind (layer) {    if(layer.kind == LayerKind.TEXT) {layerkind = "Text Layer";return layerkind;} // Text Layer    else if(layer.kind == LayerKind.SOLIDFILL) {layerkind = "Shape Layer";return layerkind; } /* Shape Layer */     else if(layer.kind == LayerKind.BLACKANDWHITE) {layerkind = "Black and White adjustment layer";return layerkind; } /* Black and White */     else if(layer.kind == LayerKind.BRIGHTNESSCONTRAST) {layerkind = "Brightness contrast adjustment layer";return layerkind; } /* Brightness contrast adjustment layer */     else if(layer.kind == LayerKind.CHANNELMIXER) {layerkind = "Channel mixer adjustment layer";return layerkind; } /* Channel mixer adjustment layer */     else if(layer.kind == LayerKind.COLORBALANCE) {layerkind = "Color balance adjustment layer";return layerkind; } /* Color balance adjustment layer */     else if(layer.kind == LayerKind.CURVES) {layerkind = "Curves adjustment layer";return layerkind; } /* Curves adjustment layer */    else if(layer.kind == LayerKind.EXPOSURE) {layerkind = "Exposure layer";return layerkind; } /* Exposure layer */     else if(layer.kind == LayerKind.GRADIENTFILL) {layerkind = "Gradient fill";return layerkind; } /* Gradient fill */     else if(layer.kind == LayerKind.GRADIENTMAP) {layerkind = "Gradient map adjustment layer";return layerkind; } /* Gradient map adjustment layer */     else if(layer.kind == LayerKind.HUESATURATION) {layerkind = "Hue saturation adjustment layer";return layerkind; } /* Hue saturation adjustment layer */     else if(layer.kind == LayerKind.INVERSION) {layerkind = "Invert adjustment layer";return layerkind; } /* Invert adjustment layer */     else if(layer.kind == LayerKind.LAYER3D) {layerkind = "3D layer";return layerkind; } /* 3D layer */    else if(layer.kind == LayerKind.LEVELS) {layerkind = "Levels adjustment layer";return layerkind; } /* Levels adjustment layer */     else if(layer.kind == LayerKind.NORMAL) {layerkind = "Normal layer";return layerkind; } /* Normal Layer */     else if(layer.kind == LayerKind.PATTERNFILL) {layerkind = "Pattern fill layer";return layerkind; } /* Pattern fill layer */     else if(layer.kind == LayerKind.PHOTOFILTER) {layerkind = "Photo filter layer";return layerkind; } /* Photo filter layer */     else if(layer.kind == LayerKind.POSTERIZE) {layerkind = "Posterize adjustment layer";return layerkind; } /* Posterize adjustment layer */     else if(layer.kind == LayerKind.SELECTIVECOLOR) {layerkind = "Selective color adjustment layer.";return layerkind; } /* Selective color adjustment layer */     else if(layer.kind == LayerKind.SMARTOBJECT) {layerkind = "Smart object layer";return layerkind; } /* Smart object layer */     else if(layer.kind == LayerKind.THRESHOLD) {layerkind = "Threshold adjustment layer";return layerkind; } /* Threshold adjustment layer */     else if(layer.kind == LayerKind.VIBRANCE) {layerkind = "Vibrance layer";return layerkind; } /* Vibrance layer */     else if(layer.kind == LayerKind.VIDEO) {layerkind = "Video layer";return layerkind; } /* Video layer */ }//Returns layers tree to the elementfunction iterateParents(layer, parents) {     var path = [];    var pathString = "";    var currLayer = layer;    do {        path.push(currLayer.parent.name);        currLayer = currLayer.parent; } while (checkParent(currLayer) == true);        path.reverse();    for (i = 0; i<path.length; i++) {        pathString += path[i]+"/";        }    return pathString;    }function checkParent (layer) {    if(layer.parent !== undefined){        if(layer.parent.name != "Adobe Photoshop" && layer.parent.name != app.activeDocument.name){            return true;        } else {            return false;            }    }    return false;}// Settings dialog:function showSettingsDialog () {	if (parseInt(app.version) < 9) {		alert("Photoshop CS2 or later is required.");		return;	}	if (!originalDoc) {		alert("Please open a document before running the PhotoshopToSpine script.");		return;	}	if (!hasFilePath()) {		alert("Please save the document before running the PhotoshopToSpine script.");		return;	}	// Layout.	var dialog = new Window("dialog", "Cthulhu Exporter "+versionTool), group;	dialog.alignChildren = "fill";        // Load JSON as well             try {            var isNewDesign = false;        var docPath = app.activeDocument.path+"/"+app.activeDocument.name;    $.writeln("Opening JSON for "+docPath);    var pathToJSON = docPath.replace(".psd", ".json");     var scriptFile = File(pathToJSON);       scriptFile.open('r');       var content = scriptFile.read();        scriptFile.close();             var masterJSON = JSON.parse(content);    $.writeln(content);        masterLayout = masterJSON;    masterLayoutSlots = masterLayout["slots"];    masterLayoutSkins = masterLayout["skins"]["default"];    } catch(ignored) {        alert("Looks like a fresh design! No JSON export exists, but worry not, click ok and we'll make a shiny new one!")        isNewDesign = true;    }	try {		dialog.add("image", undefined, new File(scriptDir() + "logo.png"));	} catch (ignored) {$.writeln("6 ERROR "+ignored)}	var settingsGroup = dialog.add("panel", undefined, "Settings");		settingsGroup.margins = [10,15,10,10];		settingsGroup.alignChildren = "fill";		var checkboxGroup = settingsGroup.add("group");			checkboxGroup.alignChildren = ["left", "top"];			group = checkboxGroup.add("group");				group.orientation = "column";				group.alignChildren = ["left", ""];				//var ignoreHiddenLayersCheckbox = group.add("checkbox", undefined, " Ignore hidden layers");				//ignoreHiddenLayersCheckbox.value = settings.ignoreHiddenLayers;                  var cleanBloadCheckbox = group.add("checkbox", undefined, " Clean Bloat");				cleanBloadCheckbox.value = settings.cleanBloat;                  var ignoreJSON = group.add("checkbox", undefined, " Export only Images");				ignoreJSON.value = settings.ignoreJSON;                  var onlyJSON = group.add("checkbox", undefined, " Export only JSON");				onlyJSON.value = settings.onlyJSON;                  var difJSON = group.add("checkbox", undefined, "Export only updated or new layers");                  difJSON.value = settings.difJSON;                                    if(isNewDesign) {                    difJSON.value = false;                    difJSON.enabled = false;                  }                                    difJSON.onClick = function (){                    onlyJSON.value = false;                    ignoreJSON.value = false;                  }                                    onlyJSON.onClick = function (){                        difJSON.value = false;                        ignoreJSON.value = false;                  }                                    ignoreJSON.onClick = function(){                        difJSON.value = false;                        onlyJSON.value = false;                  }                  			group = checkboxGroup.add("group");				group.orientation = "column";				group.alignChildren = ["left", ""];				//var writeTemplateCheckbox = group.add("checkbox", undefined, " Write template image");				//writeTemplateCheckbox.value = settings.writeTemplate;		checkboxGroup = settingsGroup.add("group");			checkboxGroup.alignment = ["left", ""];			group = checkboxGroup.add("group");				group.orientation = "column";				group.alignChildren = ["left", ""];				group.alignment = ["", "top"];				//var ignoreBackgroundCheckbox = group.add("checkbox", undefined, " Ignore background layer");				//ignoreBackgroundCheckbox.value = settings.ignoreBackground;		var scaleText, paddingText, scaleSlider, paddingSlider;		if (!cs2) {			var slidersGroup = settingsGroup.add("group");				group = slidersGroup.add("group");					group.orientation = "column";					group.alignChildren = ["right", ""];					group.add("statictext", undefined, "Scale:");					group.add("statictext", undefined, "Padding:");				group = slidersGroup.add("group");					group.orientation = "column";					scaleText = group.add("edittext", undefined, settings.scale * 100);					scaleText.characters = 4;					paddingText = group.add("edittext", undefined, settings.padding);					paddingText.characters = 4;				group = slidersGroup.add("group");					group.orientation = "column";					group.add("statictext", undefined, "%");					group.add("statictext", undefined, "px");				group = slidersGroup.add("group");					group.orientation = "column";					group.alignChildren = ["fill", ""];					group.alignment = ["fill", ""];					scaleSlider = group.add("slider", undefined, settings.scale * 100, 1, 100);					paddingSlider = group.add("slider", undefined, settings.padding, 0, 4);		} else {			group = settingsGroup.add("group");				group.add("statictext", undefined, "Scale:");				scaleText = group.add("edittext", undefined, settings.scale * 100);				scaleText.preferredSize.width = 50;			scaleSlider = settingsGroup.add("slider", undefined, settings.scale * 100, 1, 100);			group = settingsGroup.add("group");				group.add("statictext", undefined, "Padding:");				paddingText = group.add("edittext", undefined, settings.padding);				paddingText.preferredSize.width = 50;			paddingSlider = settingsGroup.add("slider", undefined, settings.padding, 0, 4);		}    var JSONPathGroupd = dialog.add("panel", undefined, "Json");    //var loadJsonButton = JSONPathGroupd.add("button", undefined, "Load Json");    //loadJsonButton.onClick = loadJson;        var checkboxModeGroup = settingsGroup.add("group");			checkboxModeGroup.alignChildren = ["left", "top"];			group = checkboxModeGroup.add("group");			group.orientation = "column";			group.alignChildren = ["left", ""];                         var docName =  String(app.activeDocument.name).toLowerCase();             var desktopCheckbox = group.add("checkbox", undefined, "Desktop");				if(docName.indexOf("desktop") != -1) {                        desktopCheckbox.value = true;                        settings.imagesDir = "./images/desktop/";                        settings.mode = "desktop";                    }                              var portraitCheckbox = group.add("checkbox", undefined, "Mobile Portrait");				if(docName.indexOf("portrait") != -1) {                        portraitCheckbox.value = true;                        settings.imagesDir = "./mobile_portrait/";                        settings.mode = "mobile_portrait";                    }                              var landscapeCheckbox = group.add("checkbox", undefined, "Mobile Landscape");				if(docName.indexOf("landscape") != -1) {                        landscapeCheckbox.value = true;                        settings.imagesDir = "./images/mobile_landscape";                        settings.mode = "mobile_landscape";                    }                                desktopCheckbox.onClick = function (){                    portraitCheckbox.value = false;                    landscapeCheckbox.value = false;                    settings.mode = "desktop";                   settings.imagesDir = "./images/desktop/";                  }                                    portraitCheckbox.onClick = function (){                        desktopCheckbox.value = false;                        landscapeCheckbox.value = false;                        settings.mode = "mobile_portrait";                        settings.imagesDir = "./mobile_portrait/";                  }                                    landscapeCheckbox.onClick = function(){                        portraitCheckbox.value = false;                        desktopCheckbox.value = false;                        settings.mode = "mobile_landscape";                        settings.imagesDir = "./images/mobile_landscape";                  }                	var outputPathGroup = dialog.add("panel", undefined, "Output Paths");		outputPathGroup.alignChildren = ["fill", ""];		outputPathGroup.margins = [10,15,10,10];		var imagesDirText, imagesDirPreview, jsonPathText, jsonPathPreview;		if (!cs2) {			var textGroup = outputPathGroup.add("group");			textGroup.orientation = "column";			textGroup.alignChildren = ["fill", ""];			group = textGroup.add("group");				group.add("statictext", undefined, "Images:");				imagesDirText = group.add("edittext", undefined, settings.imagesDir);				imagesDirText.alignment = ["fill", ""];			imagesDirPreview = textGroup.add("statictext", undefined, "");			imagesDirPreview.maximumSize.width = 260;			group = textGroup.add("group");				var jsonLabel = group.add("statictext", undefined, "JSON:");				jsonLabel.justify = "right";				jsonLabel.minimumSize.width = 41;				jsonPathText = group.add("edittext", undefined, settings.jsonPath);				jsonPathText.alignment = ["fill", ""];			jsonPathPreview = textGroup.add("statictext", undefined, "");			jsonPathPreview.maximumSize.width = 260;		} else {			outputPathGroup.add("statictext", undefined, "Images:");			imagesDirText = outputPathGroup.add("edittext", undefined, settings.imagesDir);			imagesDirText.alignment = "fill";			outputPathGroup.add("statictext", undefined, "JSON:");			jsonPathText = outputPathGroup.add("edittext", undefined, settings.jsonPath);			jsonPathText.alignment = "fill";		}	var buttonGroup = dialog.add("group");		var helpButton;		if (!cs2) helpButton = buttonGroup.add("button", undefined, "Help");		group = buttonGroup.add("group");			group.alignment = ["fill", ""];			group.alignChildren = ["right", ""];			var runButton = group.add("button", undefined, "OK");			var cancelButton = group.add("button", undefined, "Cancel");	// Tooltips.	//writeTemplateCheckbox.helpTip = "When checked, a PNG is written for the currently visible layers.";	scaleSlider.helpTip = "Scales the PNG files. Useful when using higher resolution art in Photoshop than in Spine.";	paddingSlider.helpTip = "Blank pixels around the edge of each image. Can avoid aliasing artifacts for opaque pixels along the image edge.";	imagesDirText.helpTip = "The folder to write PNGs. Begin with \"./\" to be relative to the PSD file. Blank to disable writing PNGs.";	jsonPathText.helpTip = "Output JSON file if ending with \".json\", else the folder to write the JSON file. Begin with \"./\" to be relative to the PSD file. Blank to disable writing a JSON file.";	// Events.	scaleText.onChanging = function () { scaleSlider.value = scaleText.text; };	scaleSlider.onChanging = function () { scaleText.text = Math.round(scaleSlider.value); };	paddingText.onChanging = function () { paddingSlider.value = paddingText.text; };	paddingSlider.onChanging = function () { paddingText.text = Math.round(paddingSlider.value); };	cancelButton.onClick = function () {		cancel = true;		dialog.close();        revertToInitialSave();		return;	};	if (!cs2) helpButton.onClick = showHelpDialog;	jsonPathText.onChanging = function () {		var text = jsonPathText.text ? jsonPath(jsonPathText.text) : "<no JSON output>";		if (!cs2) {			jsonPathPreview.text = text;			jsonPathPreview.helpTip = text;		} else			jsonPathText.helpTip = text;	};	imagesDirText.onChanging = function () {		var text = imagesDirText.text ? absolutePath(imagesDirText.text) : "<no image output>";		if (!cs2) {			imagesDirPreview.text = text;			imagesDirPreview.helpTip = text;		} else			imagesDirText.helpTip = text;	};	// Run now.	jsonPathText.onChanging();	imagesDirText.onChanging();	function updateSettings () {		//settings.writeTemplate = writeTemplateCheckbox.value;		//settings.ignoreHiddenLayers = ignoreHiddenLayersCheckbox.value;		//settings.ignoreBackground = ignoreBackgroundCheckbox.value;         settings.cleanBloat = cleanBloadCheckbox.value;         settings.ignoreJSON = ignoreJSON.value;         settings.onlyJSON = onlyJSON.value;         settings.difJSON = difJSON.value;                 if(settings.mode === "desktop") desktopCheckbox.value = true;           if(settings.mode === "mobile_portrait") portraitCheckbox.value = true;        if(settings.mode === "mobile_landscape") landscapeCheckbox.value = true;		var scaleValue = parseFloat(scaleText.text);		if (scaleValue > 0 && scaleValue <= 100) settings.scale = scaleValue / 100;		settings.imagesDir = imagesDirText.text;		settings.jsonPath = jsonPathText.text;		var paddingValue = parseInt(paddingText.text);		if (paddingValue >= 0) settings.padding = paddingValue;	}	runButton.onClick = function () {		if (scaleText.text <= 0 || scaleText.text > 100) {			alert("Scale must be between > 0 and <= 100.");			return;		}		if (paddingText.text < 0) {			alert("Padding must be >= 0.");			return;		}		updateSettings();		saveSettings();		//writeTemplateCheckbox.enabled = false;		//ignoreHiddenLayersCheckbox.enabled = false;		//ignoreBackgroundCheckbox.enabled = false;		scaleText.enabled = false;		scaleSlider.enabled = false;		paddingText.enabled = false;		paddingSlider.enabled = false;		imagesDirText.enabled = false;		jsonPathText.enabled = false;		if (!cs2) helpButton.enabled = false;		runButton.enabled = false;		cancelButton.enabled = false;		var rulerUnits = app.preferences.rulerUnits;		app.preferences.rulerUnits = Units.PIXELS;         run();		try {			// var start = new Date().getTime();			//run();			// alert(new Date().getTime() - start);		} catch (e) {			alert("7 ERROR An unexpected error has occurred.\n\nTo debug, run the PhotoshopToSpine script using Adobe ExtendScript "				+ "with \"Debug > Do not break on guarded exceptions\" unchecked.");			debugger;		} finally {			if (activeDocument != originalDoc) activeDocument.close(SaveOptions.DONOTSAVECHANGES);			app.preferences.rulerUnits = rulerUnits;			dialog.close();		}	};	dialog.center();	dialog.show();}function loadJson() {        var myFile = File.openDialog("Selection prompt");    var pathToJSON = (myFile.path)+"/"+String(myFile.name).replace(".psd", ".json");     var scriptFile = File(pathToJSON);       scriptFile.open('r');       var content = scriptFile.read();        scriptFile.close();             var masterJSON = JSON.parse(content);    $.writeln(JSON.parse(content));        alert ("JSON loaded");        masterLayout = masterJSON;    masterLayoutSlots = masterLayout["slots"];    masterLayoutSkins = masterLayout["skins"]["default"]    }function loadSettings () {	var options = null;	try {		options = app.getCustomOptions(sID("settings"));	} catch (e) {        $.writeln("8 ERROR "+e)	}	var settings = {};	for (var key in defaultSettings) {		if (!defaultSettings.hasOwnProperty(key)) continue;		var typeID = sID(key);		if (options && options.hasKey(typeID))			settings[key] = options["get" + getOptionType(defaultSettings[key])](typeID);		else			settings[key] = defaultSettings[key];	}	return settings;}function saveSettings () {	if (cs2) return; // No putCustomOptions.	var action = new ActionDescriptor();	for (var key in defaultSettings) {		if (!defaultSettings.hasOwnProperty(key)) continue;		action["put" + getOptionType(defaultSettings[key])](sID(key), settings[key]);	}	app.putCustomOptions(sID("settings"), action, true);}function getOptionType (value) {	switch (typeof(value)) {	case "boolean": return "Boolean";	case "string": return "String";	case "number": return "Double";	};	throw new Error("Invalid default setting: " + value);}// Help dialog.function showHelpDialog () {	var dialog = new Window("dialog", "PhotoshopToSpine - Help");	dialog.alignChildren = ["fill", ""];	dialog.orientation = "column";	dialog.alignment = ["", "top"];	var helpText = dialog.add("statictext", undefined, ""		+ "This script writes layers as images and creates a JSON file to bring the images into Spine in the same positions and draw order as they had in Photoshop.\n"		+ "\n"		+ "The ruler origin corresponds to 0,0 in Spine.\n"		+ "\n"		+ "Tags in square brackets can be used in layer and group names to customize the output.\n"		+ "\n"		+ "Group names:\n"		+ "•  [slot]  Layers in the group are placed in a slot, named after the group.\n"		+ "•  [skin]  Layers in the group are placed in a skin, named after the group. Skin images are output in a subfolder for the skin.\n"		+ "•  [merge]  Layers in the group are merged and a single image is output, named after the group.\n"		+ "•  [folder]  Layers in the group will be output in a subfolder. Folder groups can be nested.\n"		+ "•  [ignore]  Layers in the group and any child groups will not be output.\n"		+ "\n"		+ "Layer names:\n"		+ "•  [ignore]  The layer will not be output."	, {multiline: true});	helpText.preferredSize.width = 325;	var closeButton = dialog.add("button", undefined, "Close");	closeButton.alignment = ["center", ""];	closeButton.onClick = function () {		dialog.close();	};	dialog.center();	dialog.show();}// Progress dialog:function showProgressDialog () {	var dialog = new Window("palette", "Cthulhu is thinking...");	dialog.alignChildren = "fill";	dialog.orientation = "column";	var message = dialog.add("statictext", undefined, "Cthulhu is waking up...");	var group = dialog.add("group");		var bar = group.add("progressbar");		bar.preferredSize = [300, 16];		bar.maxvalue = 10000;		var cancelButton = group.add("button", undefined, "Try stopping Cthulhu!");	cancelButton.onClick = function () {		cancel = true;		cancelButton.enabled = false;		return;	};	dialog.center();	dialog.show();	dialog.active = true;	progress = {		dialog: dialog,		bar: bar,		message: message	};}function setProgress (percent, layerName) {	progress.bar.value = 10000 * percent;	progress.message.text = "Layer: " + layerName;	if (!progress.dialog.active) progress.dialog.active = true;}// PhotoshopToSpine utility:function collectLayers (parent, collect) {	for (var i = parent.layers.length - 1; i >= 0; i--) {        curr++;		if (cancel) return;		var layer = parent.layers[i];		if (settings.ignoreHiddenLayers && !layer.visible) {			layer.remove();			continue;		}		if (settings.ignoreBackground && layer.isBackgroundLayer) {			layer.remove();			continue;		}		if (hasTag(layer, "ignore")) {			layer.remove();			continue;		}		var group = isGroup(layer);		if (!group && layer.bounds[2] == 0 && layer.bounds[3] == 0) {			layer.remove();			continue;		}		// Ensure tags are valid.		var re = /\[([^\]]+)\]/g;		while (true) {			var matches = re.exec(layer.name);			if (!matches) break;			var tag = matches[1].toLowerCase();			if (group) {				if (!isValidGroupTag(tag)) {					var message = "Invalid group name:\n\n" + layer.name;					if (isValidLayerTag(tag))						message += "\n\nThe [" + tag + "] tag is only valid for layers, not for groups.";					else						message += "\n\nThe [" + tag + "] tag is not a valid tag.";					alert(message);					cancel = true;					return;				}			} else if (!isValidLayerTag(tag)) {				var message = "Invalid layer name:\n\n" + layer.name;				if (isValidGroupTag(tag))					message += "\n\nThe [" + tag + "] tag is only valid for groups, not for layers.";				else					message += "\n\nThe [" + tag + "] tag is not a valid tag.";				alert(message);				cancel = true;				return;			}		}		// Ensure only one tag.		if (layer.name.replace(/\[[^\]]+\]/, "").search(/\[[^\]]+\]/) != -1) {			alert("A " + (group ? "group" : "layer") + " name must not have more than one tag:\n" + layer.name);			cancel = true;			return;		}          //var uuid = Math.random();      var uuid = curr+Math.random();        //Ensure layer name is Unique and no duplicates        if(layersNames[layer.name] === undefined)         {            layersNames[layer.name] = 1;        } else {            if(!isGroup(layer)) {                curr++                layersNames[layer.name] += 1;                //rename duplicate                //layer.name = layer.name + "#"+layersNames[layer.name];                }            }		layer.wasVisible = layer.visible;		if (group && hasTag(layer, "merge")) {			layer.visible = true;			collectGroupMerge(layer);			if (!layer.layers || layer.layers.length == 0) continue;		} else if (layer.visible && layer.layers && layer.layers.length > 0) {			//layer.visible = true;			collectLayers(layer, collect);			continue;		} else if (layer.kind == LayerKind.NORMAL)			process = true;		else {			layer.remove();			continue;		}		if (parent.allLocked) {			activeDocument.activeLayer = layer;			parent.allLocked = false;		}		layer.allLocked = false;		layer.visible = false;		//collect.push(layer);                var uniqueObject = {uid:uuid, layer:layer}        /*if(getLayerColourByID(layer.id) == "violet"){            layersToRemove.push(layer)         }        else {            collect.push(uniqueObject);        }*/     collect.push(uniqueObject);	}}function getLayerColourByID( ID ) {   var ref = new ActionReference();   ref.putProperty( charIDToTypeID("Prpr") ,stringIDToTypeID('color'));   ref.putIdentifier(charIDToTypeID( "Lyr " ), ID );  return typeIDToStringID(executeActionGet(ref).getEnumerationValue(stringIDToTypeID('color')));   };  function collectGroupMerge (parent) {	if (!parent.layers) return;	for (var i = parent.layers.length - 1; i >= 0; i--) {		var layer = parent.layers[i];		if (settings.ignoreHiddenLayers && !layer.visible) {			layer.remove();			continue;		}		if (hasTag(layer, "ignore")) {			layer.remove();			continue;		}		collectGroupMerge(layer);	}}function isValidGroupTag (tag) {	switch (tag) {	case "slot":	case "skin":	case "merge":	case "folder":	case "ignore":		return true;	}	return false;}function isValidLayerTag (tag) {	switch (tag) {	case "ignore":		return true;	}	return false;}function isGroup (layer) {	return layer.typename == "LayerSet";}function stripTags (name) {	return trim(name.replace(/\[[^\]]+\]/g, ""));}function hasTagLayer (layer, tag) {	while (layer) {		if (tag == "ignore" || isGroup(layer)) { // Non-group layers can only have ignore tag.			if (layer.name.toLowerCase().indexOf("[" + tag + "]") != -1) return layer;		}		layer = layer.parent;	}	return null;}function hasTag (layer, tag, otherwise) {	var found = hasTagLayer(layer, tag);	return found ? stripTags(found.name) : otherwise;}function jsonPath (jsonPath) {	if (endsWith(jsonPath, ".json")) {		var index = jsonPath.replace("\\", "/").lastIndexOf("/");		if (index != -1) return absolutePath(jsonPath.slice(0, index + 1)) + jsonPath.slice(index + 1);		return absolutePath("./") + jsonPath;	} 	var name = decodeURI(originalDoc.name);	return absolutePath(jsonPath) + name.substring(0, name.indexOf(".")) + ".json";}function folders (layer, path) {	var folderLayer = hasTagLayer(layer, "folder");	return folderLayer ? folders(folderLayer.parent, stripTags(folderLayer.name) + "/" + path) : path;}// Photoshop utility:function scaleImage () {	var imageSize = activeDocument.width.as("px") * settings.scale;	activeDocument.resizeImage(UnitValue(imageSize, "px"), null, null, ResampleMethod.BICUBICSHARPER);}var history;function storeHistory () {	history = activeDocument.activeHistoryState;}function restoreHistory () {	activeDocument.activeHistoryState = history;}function scriptDir () {	var file;	if (!cs2)		file = $.fileName;	else {		try {			var error = THROW_ERROR; // Force error which provides the script file name.		} catch (ex) {            $.writeln("9 ERROR "+ex)			file = ex.fileName;		}	}	return new File(file).parent + "/";}function hasFilePath () {	var action = new ActionReference();	action.putEnumerated(cID("Dcmn"), cID("Ordn"), cID("Trgt"));	return executeActionGet(action).hasKey(sID("fileReference"));}function absolutePath (path) {	path = trim(path);	if (!startsWith(path, "./")) {		var absolute = decodeURI(new File(path).absoluteURI);		if (!startsWith(absolute, decodeURI(new File("child").parent.absoluteURI))) return absolute + "/";		path = "./" + path;	}	if (path.length == 0)		path = decodeURI(activeDocument.path);	else if (startsWith(settings.imagesDir, "./"))		path = decodeURI(activeDocument.path) + path.substring(1);	path = path.replace(/\\/g, "/");	if (path.substring(path.length - 1) != "/") path += "/";	return path;}function cID (id) {	return charIDToTypeID(id);}function sID (id) {	return stringIDToTypeID(id);}function bgColor (control, r, g, b) {	control.graphics.backgroundColor = control.graphics.newBrush(control.graphics.BrushType.SOLID_COLOR, [r, g, b]);}function deselectLayers () {	var desc = new ActionDescriptor();	var ref = new ActionReference();	ref.putEnumerated(cID("Lyr "), cID("Ordn"), cID("Trgt"));	desc.putReference(cID("null"), ref);	executeAction(sID("selectNoLayers"), desc, DialogModes.NO);}function convertToRGB () {	var desc = new ActionDescriptor();	desc.putClass(cID("T   "), cID("RGBM"));	desc.putBoolean(cID("Mrge"), false);	desc.putBoolean(cID("Rstr"), true);	executeAction(cID("CnvM"), desc, DialogModes.NO);}function savePNG (file) {    if(!settings.onlyJSON){        var options = new PNGSaveOptions();                opts = new ExportOptionsSaveForWeb();        opts.format = SaveDocumentType.PNG;        opts.PNG8 = true;        opts.quality = 10;                options.compression = 9;        options.embedColorProfile = true;        options.formatOptions = FormatOptions.STANDARDBASELINE;        options.quality = 1;        options.matte = MatteType.NONE        options.interlaced = false;        activeDocument.saveAs(file, options, true, Extension.LOWERCASE);              //activeDocument.exportDocument(file, ExportType.SAVEFORWEB, opts);    }}// JavaScript utility:function countAssocArray (obj) {	var count = 0;	for (var key in obj)		if (obj.hasOwnProperty(key)) count++;	return count;}function trim (value) {	return value.replace(/^\s+|\s+$/g, "");}function startsWith (str, prefix) {	return str.indexOf(prefix) === 0;}function endsWith (str, suffix) {	return str.indexOf(suffix, str.length - suffix.length) !== -1;}function quote (value) {	return '"' + value.replace('"', '\\"') + '"';}